"""
Database Connection Management Tests - Unified Suite

This module contains comprehensive tests for the database connection management
functionality in the application. It covers basic connection operations, concurrent
access patterns, transaction management, and error handling scenarios.
"""

import pytest
import os
import sqlite3
import pandas as pd
import threading
import time
import uuid
import contextlib
from concurrent.futures import ThreadPoolExecutor, as_completed
import queue
from pathlib import Path
import tempfile
from unittest.mock import patch, MagicMock
import importlib
import gc
import traceback
import inspect
import json
from datetime import datetime
import shutil
import deployment.app.config as config
from deployment.app.db.database import (
    get_db_connection,
    db_transaction,
    execute_many,
    DatabaseError,
    create_job, 
    update_job_status,
    get_job,
    dict_factory
)
from deployment.app.db.schema import init_db
from deployment.app.models.api_models import JobStatus, JobType

# ==========================================
# Helper functions and context managers
# ==========================================

def is_connection_valid(conn):
    """
    Check if a SQLite connection is still valid/open.
    
    Args:
        conn: The SQLite connection to check
        
    Returns:
        bool: True if connection is valid, False otherwise
    """
    try:
        conn.execute("SELECT 1")
        return True
    except (sqlite3.ProgrammingError, sqlite3.OperationalError):
        return False

def generate_unique_job_id(prefix="test_job"):
    """
    Generate a unique job ID with optional prefix.
    
    Args:
        prefix: Prefix for the job ID
        
    Returns:
        str: A unique job ID
    """
    return f"{prefix}_{uuid.uuid4().hex[:8]}"

# ==========================================
# Fixtures
# ==========================================

@pytest.fixture(scope="function")
def mock_fs_setup():
    """Set up a mock file system for tests."""
    pass

# ==========================================
# Basic connection management tests
# ==========================================

def test_db_connection_is_properly_closed(isolated_db_session):
    """Ensure that the get_db_connection and close_db_connection functions work correctly."""
    conn = get_db_connection(db_path_override=isolated_db_session)
    assert conn is not None, "Failed to get a database connection."
    assert isinstance(conn, sqlite3.Connection), "Connection is not a sqlite3.Connection object."

    # Verify the connection is open
    try:
        conn.execute("SELECT 1")
    except sqlite3.ProgrammingError as e:
        pytest.fail(f"Connection is not usable: {e}")

    conn.close()

    # Verify the connection is closed
    with pytest.raises(sqlite3.ProgrammingError, match="Cannot operate on a closed database."):
        conn.cursor()

def test_row_factory_behavior(isolated_db_session):
    """Check that the row factory is set to the correct dict_factory."""
    conn = get_db_connection(db_path_override=isolated_db_session)
    assert conn.row_factory == dict_factory, "Database connection does not use dict_factory as row factory."
    conn.close()

def test_concurrent_connections(isolated_db_session):
    """Test the ability to handle multiple concurrent database connections."""
    num_threads = 5

    def get_use_and_close_connection():
        # Each thread must get, use, and close its own connection
        try:
            thread_conn = get_db_connection(db_path_override=isolated_db_session)
            assert thread_conn is not None
            # Perform a simple operation
            thread_conn.execute("SELECT 1")
            thread_conn.close()
            # Verify it's closed
            with pytest.raises(sqlite3.ProgrammingError):
                thread_conn.cursor()
            return True
        except Exception as e:
            print(f"A thread failed during connection lifecycle: {e}")
            return False

    with ThreadPoolExecutor(max_workers=num_threads) as executor:
        futures = [executor.submit(get_use_and_close_connection) for _ in range(num_threads)]
        results = [future.result() for future in as_completed(futures)]

    assert all(results), "One or more threads failed to manage its connection."

# ==========================================
# Concurrent operations and transaction tests
# ==========================================

def test_concurrent_writes(isolated_db_session):
    """Test concurrent writes to the database to check for locking issues."""
    num_writes = 10
    init_db(isolated_db_session) # Ensure tables are created

    def write_task(conn_str):
        try:
            with db_transaction(conn_str) as conn:
                # job_id is generated by create_job, so we don't pass it.
                create_job(JobType.TRAINING.value, {"params":"value"}, connection=conn)
            return True
        except Exception as e:
            # Capture the error for debugging
            print(f"Error during write task: {e}")
            return False

    with ThreadPoolExecutor(max_workers=num_writes) as executor:
        futures = [executor.submit(write_task, isolated_db_session) for _ in range(num_writes)]
        results = [future.result() for future in as_completed(futures)]

    assert all(results), "Not all write tasks completed successfully."

    # Verify that all writes were successful
    with get_db_connection(isolated_db_session) as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM jobs")
        count = cursor.fetchone()['COUNT(*)']
        assert count == num_writes, f"Expected {num_writes} records, but found {count}."

def test_transaction_isolation(isolated_db_session):
    """Test that transactions properly isolate operations."""
    # Setup initial state
    with get_db_connection(isolated_db_session) as conn:
        job_id = create_job(JobType.TRAINING.value, {"params": "config"}, connection=conn)

    # This test requires two concurrent, open connections to test isolation.
    conn1 = get_db_connection(isolated_db_session)
    conn2 = get_db_connection(isolated_db_session)
    try:
        # Start a transaction in conn1 and update a job
        with db_transaction(conn1):
            update_job_status(job_id, JobStatus.RUNNING.value, connection=conn1)

            # In conn2, the change should NOT be visible yet
            status_before_commit = get_job(job_id, connection=conn2)['status']
            assert status_before_commit == JobStatus.PENDING.value, \
                f"Change was visible inside transaction. Expected '{JobStatus.PENDING.value}', got '{status_before_commit}'."

        # After the transaction in conn1 commits, the change should be visible
        status_after_commit = get_job(job_id, connection=conn2)['status']
        assert status_after_commit == JobStatus.RUNNING.value, \
            f"Change was not visible after commit. Expected '{JobStatus.RUNNING.value}', got '{status_after_commit}'."

    finally:
        # Explicitly close the connections used in this test
        if conn1:
            conn1.close()
        if conn2:
            conn2.close()

def test_connection_context_manager(isolated_db_session):
    """Test the db_transaction context manager for commit and rollback."""
    # These variables are no longer used to fetch the job, but serve as documentation.
    # job_id_commit = "commit_job"
    # job_id_rollback = "rollback_job"

    # Test successful commit
    try:
        with db_transaction(isolated_db_session) as conn: # Use the context manager to get a connection
            create_job(job_type=JobType.PREDICTION.value, parameters={"params": "commit"}, connection=conn)
    except Exception as e:
        pytest.fail(f"Commit transaction failed unexpectedly: {e}")

    # Verify commit
    with get_db_connection(isolated_db_session) as conn_verify:
        # We don't know the exact job_id, so we check if a job with the correct params exists
        res = conn_verify.execute("SELECT * FROM jobs WHERE parameters = ?", (json.dumps({"params": "commit"}),)).fetchone()
        assert res is not None, "Job that should have been committed was not found."

    # Test rollback on exception
    try:
        with db_transaction(isolated_db_session) as conn:
            create_job(job_type=JobType.TRAINING.value, parameters={"params": "rollback"}, connection=conn)
            raise ValueError("Simulating an error to trigger rollback")
    except DatabaseError: # Changed from ValueError to DatabaseError
        pass  # Expected error

    # Verify rollback
    with get_db_connection(isolated_db_session) as conn_verify:
        res = conn_verify.execute("SELECT * FROM jobs WHERE parameters = ?", (json.dumps({"params": "rollback"}),)).fetchone()
        assert res is None, "Job that should have been rolled back was found."

# ==========================================
# Error handling and recovery tests
# ==========================================

def test_connection_error_recovery(isolated_db_session):
    """Simulate a connection failure and test recovery."""
    conn = get_db_connection(db_path_override=isolated_db_session)
    # Manually close the connection to simulate an error
    conn.close()

    # The next call should ideally re-establish the connection or handle it gracefully.
    # Depending on the implementation, this might raise an error or return a new connection.
    # Let's test for a graceful failure when trying to use the closed connection.
    with pytest.raises(sqlite3.ProgrammingError):
        conn.execute("SELECT 1")

    # Now, test if a fresh call to get_db_connection can succeed
    try:
        new_conn = get_db_connection(db_path_override=isolated_db_session)
        assert new_conn is not None
        new_conn.execute("SELECT 1") # Should not raise an error
        new_conn.close()
    except Exception as e:
        pytest.fail(f"Failed to recover and get a new connection: {e}")

def test_execute_query_error_handling(isolated_db_session):
    """Test that db_transaction correctly handles SQL errors."""
    with pytest.raises(DatabaseError) as excinfo:
        with db_transaction(isolated_db_session) as conn:
            # This will fail because the table does not exist
            conn.execute("SELECT * FROM non_existent_table")
    
    # Check that the exception is of the correct type
    assert "no such table: non_existent_table" in str(excinfo.value)

# ==========================================
# Database function tests
# ==========================================

def test_create_job_function(isolated_db_session):
    """Test the create_job function."""
    job_type = JobType.PREDICTION
    params = {"key": "value"}

    with db_transaction(isolated_db_session) as conn:
        # The function generates its own job_id
        returned_job_id = create_job(job_type.value, params, connection=conn)

        assert returned_job_id is not None
        job = get_job(returned_job_id, connection=conn)

    assert job is not None
    assert job['job_type'] == job_type.value
    assert job['status'] == 'pending'
    # config_id is not part of the new signature
    # assert job['config_id'] == 'config123' 
    assert isinstance(json.loads(job['parameters']), dict)
    assert json.loads(job['parameters'])['key'] == 'value'

def test_execute_many_function(isolated_db_session):
    """Test the execute_many function for bulk inserts."""
    init_db(isolated_db_session)
    now_iso = datetime.utcnow().isoformat()
    data_to_insert = [
        (generate_unique_job_id(), JobType.TRAINING.value, JobStatus.PENDING.value, now_iso, now_iso, '{}'),
        (generate_unique_job_id(), JobType.PREDICTION.value, JobStatus.PENDING.value, now_iso, now_iso, '{}'),
    ]
    sql = "INSERT INTO jobs (job_id, job_type, status, created_at, updated_at, parameters) VALUES (?, ?, ?, ?, ?, ?)"

    with db_transaction(isolated_db_session) as conn:
        execute_many(sql, data_to_insert, conn)

    with get_db_connection(isolated_db_session) as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM jobs WHERE job_id LIKE 'test_job_%'")
        count = cursor.fetchone()['COUNT(*)']
        assert count == 2 